# 上下文增强实验设计 (Exp 6.1b/6.2)

## 📊 当前实验结果分析

### 基线对比

| 实验 | MRR | R@10 | NDCG@10 | 说明 |
|------|-----|------|---------|------|
| Pipeline Optimized | 0.3428 | 0.5996 | 0.3977 | 基线（fine-tuned模型） |
| Exp 6.1 (Query Enhancement) | 0.3414 | 0.5953 | 0.3954 | +source_paper信息 |

**观察**：
- Exp 6.1 的 MRR 实际上**略低于**基线（-0.14%）
- 这可能说明：
  1. source_paper 信息可能引入了噪声
  2. 或者需要更好的融合策略
  3. 或者 citation_context 本身已经足够

---

## 🎯 上下文增强实验设计

### 实验假设

**假设**: 引用句的前后文（context_before, context_after）包含重要的语义信息，能够：
1. 提供更完整的语义上下文
2. 帮助理解引用句的意图
3. 减少歧义

### 数据可用性分析

根据数据检查：
- ✅ 原始数据中有 `context_before` 和 `context_after`
- ⚠️ 转换后的数据可能丢失了这些信息
- 📝 需要确认数据格式，可能需要重新转换或修改数据加载

---

## 🔬 实验设计方案

### 方案A: 渐进式增强（推荐）⭐⭐⭐⭐⭐

**思路**: 逐步添加上下文信息，观察每个组件的贡献

#### Exp 6.1b.1: 仅添加前后文
- **查询**: `context_before + citation_context + context_after`
- **基线**: Pipeline Optimized (MRR=0.3428)
- **预期**: MRR = 0.35-0.37 (+2-8%)
- **时间**: 2-3小时

#### Exp 6.1b.2: 前后文 + Source Paper
- **查询**: `context_before + citation_context + context_after + source_title + source_abstract`
- **基线**: Exp 6.1 (MRR=0.3414)
- **预期**: MRR = 0.36-0.39 (+5-14%)
- **时间**: 2-3小时

#### Exp 6.1b.3: 加权组合（如果效果好）
- **查询**: `α*context_before + β*citation_context + γ*context_after + δ*source_info`
- **需要**: 超参数调优
- **预期**: MRR = 0.37-0.40 (+8-17%)
- **时间**: 1-2天

---

### 方案B: 上下文长度控制 ⭐⭐⭐⭐

**思路**: 控制上下文长度，避免查询过长导致性能下降

#### Exp 6.1b.4: 短上下文（各50词）
- **查询**: `context_before[:50] + citation_context + context_after[:50]`
- **预期**: 平衡信息量和查询长度
- **时间**: 2-3小时

#### Exp 6.1b.5: 中等上下文（各100词）
- **查询**: `context_before[:100] + citation_context + context_after[:100]`
- **预期**: 更多信息，但可能过长
- **时间**: 2-3小时

#### Exp 6.1b.6: 长上下文（各200词）
- **查询**: `context_before[:200] + citation_context + context_after[:200]`
- **预期**: 最多信息，但可能引入噪声
- **时间**: 2-3小时

---

### 方案C: 上下文选择策略 ⭐⭐⭐

**思路**: 不是所有上下文都有用，需要智能选择

#### Exp 6.1b.7: 基于重要性的上下文选择
- **方法**: 使用 TF-IDF 或 BM25 选择最相关的上下文片段
- **预期**: 减少噪声，提高相关性
- **时间**: 3-5天（需要实现选择算法）

#### Exp 6.1b.8: 基于位置的上下文选择
- **方法**: 只使用紧邻的句子（前1句+后1句）
- **预期**: 最相关的上下文
- **时间**: 2-3小时

---

## 📋 推荐实验顺序

### Phase 1: 快速验证（1天）

1. **Exp 6.1b.1** (仅前后文)
   - 最快验证上下文是否有用
   - 如果效果好（MRR > 0.35），继续
   - 如果效果不好，可能需要调整策略

2. **Exp 6.1b.4** (短上下文)
   - 如果 Exp 6.1b.1 效果好，测试不同长度
   - 找到最优长度

### Phase 2: 组合实验（1-2天）

3. **Exp 6.1b.2** (前后文 + Source Paper)
   - 组合两种增强方式
   - 看是否有协同效应

4. **Exp 6.1b.8** (紧邻句子)
   - 如果长上下文效果不好，尝试只使用紧邻句子

### Phase 3: 优化（可选，2-3天）

5. **Exp 6.1b.3** (加权组合)
   - 如果前面的实验效果好，进一步优化

---

## 🎯 预期结果对比

| 实验 | 查询组成 | 预期MRR | 提升 | 优先级 |
|------|---------|---------|------|--------|
| 基线 | citation_context | 0.3428 | - | - |
| 6.1b.1 | context_before + citation + context_after | 0.35-0.37 | +2-8% | ⭐⭐⭐⭐⭐ |
| 6.1b.2 | 6.1b.1 + source_paper | 0.36-0.39 | +5-14% | ⭐⭐⭐⭐ |
| 6.1b.4 | 短上下文（各50词） | 0.35-0.37 | +2-8% | ⭐⭐⭐ |
| 6.1b.8 | 紧邻句子 | 0.35-0.37 | +2-8% | ⭐⭐⭐ |

---

## ⚠️ 潜在问题和解决方案

### 问题1: 查询过长
- **现象**: 添加上下文后查询过长，模型性能下降
- **解决**: 
  - 限制上下文长度（50-100词）
  - 使用截断策略（head/tail）
  - 只使用紧邻句子

### 问题2: 上下文噪声
- **现象**: 前后文包含不相关信息，引入噪声
- **解决**:
  - 使用重要性选择（TF-IDF/BM25）
  - 只使用紧邻句子
  - 加权组合（降低上下文权重）

### 问题3: 数据格式问题
- **现象**: 转换后的数据丢失了 context_before/after
- **解决**:
  - 修改数据转换脚本，保留这些字段
  - 或者从原始数据重新加载

---

## 🔧 实施建议

### 第一步: 数据检查
```python
# 检查数据中是否有 context_before/after
# 如果没有，需要修改数据加载逻辑
```

### 第二步: 实现基础版本
```python
# 实现 Exp 6.1b.1: 仅前后文
query_text = f"{context_before} {citation_context} {context_after}"
```

### 第三步: 运行实验
```bash
# 运行 Exp 6.1b.1
python scripts/run_all_experiments.py --experiment exp_6_1b_1_context --data_dir data/processed/fast_experiment
```

### 第四步: 根据结果调整
- 如果效果好 → 继续 Phase 2
- 如果效果不好 → 尝试不同策略（长度控制、选择策略）

---

## 📊 成功标准

- **最小成功**: MRR > 0.35 (+2%以上)
- **目标成功**: MRR > 0.37 (+8%以上)
- **优秀成功**: MRR > 0.39 (+14%以上)

---

## 💡 关键考虑

1. **上下文长度**: 太短可能信息不足，太长可能引入噪声
2. **位置权重**: citation_context 应该是最重要的，前后文是辅助
3. **数据质量**: 确保 context_before/after 确实存在且有用
4. **模型限制**: 某些模型（如 BM25）可能不适合过长的查询

---

## 🎓 论文写作建议

如果实验成功，可以这样组织：

1. **Baseline**: Pipeline Optimized (MRR=0.3428)
2. **+Context**: Exp 6.1b.1 (MRR=0.36)
3. **+Context+Source**: Exp 6.1b.2 (MRR=0.38)
4. **Ablation**: 不同上下文长度的对比

这样可以清楚展示每个组件的贡献！

